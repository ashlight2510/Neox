<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0a0a12" />
  <title>NEOX ‚Äî Neo Arcade Shooter</title>
  <meta name="description" content="Í∞§Îü¨Í∑∏ Ïä§ÌÉÄÏùº ÎÑ§Ïò§ ÏäàÌåÖ. Ï†Å Í≤©Ï∂î, Ïõ®Ïù¥Î∏å ÌÅ¥Î¶¨Ïñ¥, Ï†êÏàò Ï±åÎ¶∞ÏßÄ." />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'><stop offset='0%25' style='stop-color:%2306b6d4'/><stop offset='100%25' style='stop-color:%22d3ee'/></linearGradient><filter id='glow'><feGaussianBlur stdDeviation='2' result='b'/><feMerge><feMergeNode in='b'/><feMergeNode in='SourceGraphic'/></feMerge></filter></defs><rect width='100' height='100' rx='12' fill='%230a0a12'/><path d='M50 25 L58 45 L78 48 L62 62 L66 82 L50 72 L34 82 L38 62 L22 48 L42 45 Z' fill='url(%23g)' filter='url(%23glow)'/></svg>" />
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; overflow: hidden; height: 100%; }
    body {
      background: #0a0a12;
      font-family: 'JetBrains Mono', 'SF Mono', 'Fira Code', monospace;
      color: #e2e8f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    .game-wrap {
      position: relative;
      width: min(100vw, 96vh * 0.6);
      max-width: 480px;
      aspect-ratio: 3 / 4;
      border-radius: 16px;
      overflow: hidden;
      box-shadow:
        0 0 0 1px rgba(6, 182, 212, 0.3),
        0 0 40px rgba(6, 182, 212, 0.15),
        inset 0 0 60px rgba(0, 0, 0, 0.5);
    }
    #c {
      display: block;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse 80% 50% at 50% 0%, rgba(6, 182, 212, 0.08) 0%, transparent 50%),
                  linear-gradient(180deg, #0a0a12 0%, #050508 100%);
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .scanlines {
      pointer-events: none;
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 0, 0, 0.12) 2px,
        rgba(0, 0, 0, 0.12) 4px
      );
      border-radius: 16px;
      opacity: 0.6;
    }
    .hud {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: linear-gradient(180deg, rgba(10, 10, 18, 0.9) 0%, transparent 100%);
      z-index: 10;
    }
    .hud span {
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.1em;
      color: #06b6d4;
      text-shadow: 0 0 12px rgba(6, 182, 212, 0.8);
    }
    .hud .score { color: #22d3ee; }
    .hud .gold { color: #fbbf24; text-shadow: 0 0 10px rgba(251, 191, 36, 0.6); }
    .hud .wave { color: #a78bfa; text-shadow: 0 0 12px rgba(167, 139, 250, 0.8); }
    .hud .lives { color: #f472b6; }
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(10, 10, 18, 0.92);
      z-index: 20;
      border-radius: 16px;
    }
    .overlay.hidden { display: none; }
    .overlay h1 {
      margin: 0 0 8px;
      font-size: clamp(1.5rem, 6vw, 2.2rem);
      font-weight: 800;
      letter-spacing: 0.2em;
      background: linear-gradient(135deg, #06b6d4, #22d3ee, #a78bfa);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 40px rgba(6, 182, 212, 0.5);
    }
    .overlay .kicker {
      font-size: 10px;
      letter-spacing: 0.3em;
      color: #64748b;
      margin-bottom: 24px;
    }
    .overlay p {
      font-size: 13px;
      color: #94a3b8;
      margin: 0 0 24px;
      max-width: 280px;
      text-align: center;
      line-height: 1.6;
    }
    .btn {
      padding: 14px 32px;
      border: none;
      border-radius: 12px;
      font-family: inherit;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.1em;
      cursor: pointer;
      background: linear-gradient(135deg, #06b6d4, #0891b2);
      color: #0a0a12;
      box-shadow: 0 0 24px rgba(6, 182, 212, 0.5);
      transition: transform 0.15s, box-shadow 0.15s;
    }
    .btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 32px rgba(6, 182, 212, 0.7);
    }
    .btn:active { transform: scale(0.98); }
    .touch-btn { font-family: inherit; user-select: none; -webkit-tap-highlight-color: transparent; }
    .touch-btn:active { transform: scale(0.95); opacity: 0.9; }
    .game-over .final-score {
      font-size: 18px;
      color: #22d3ee;
      margin-bottom: 20px;
      text-shadow: 0 0 16px rgba(34, 211, 238, 0.8);
    }
    .shop { padding: 16px; max-height: 85vh; overflow-y: auto; }
    .shop h2 { font-size: 1rem; margin: 0 0 8px; color: #a78bfa; }
    .shop .gold-display { font-size: 1.1rem; color: #fbbf24; margin-bottom: 16px; font-weight: 700; }
    .shop-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 14px;
      margin-bottom: 8px;
      background: rgba(30, 30, 40, 0.8);
      border-radius: 10px;
      border: 1px solid rgba(167, 139, 250, 0.25);
    }
    .shop-item .info { flex: 1; font-size: 12px; color: #94a3b8; }
    .shop-item .name { font-weight: 700; color: #e2e8f0; margin-bottom: 2px; }
    .shop-item .btn-buy {
      padding: 8px 14px;
      border: none;
      border-radius: 8px;
      font-family: inherit;
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
      background: linear-gradient(135deg, #a78bfa, #8b5cf6);
      color: #0a0a12;
      white-space: nowrap;
    }
    .shop-item .btn-buy:hover { filter: brightness(1.15); }
    .shop-item .btn-buy:disabled { opacity: 0.5; cursor: not-allowed; filter: none; }
    .shop-item .lvl { font-size: 10px; color: #64748b; margin-top: 2px; }
    .shop .btn-next { margin-top: 16px; }
  </style>
</head>
<body>
  <div class="game-wrap">
    <canvas id="c"></canvas>
    <div class="scanlines"></div>
    <div class="hud">
      <span class="score">SCORE <b id="scoreNum">0</b></span>
      <span class="gold">ü™ô <b id="goldNum">0</b></span>
      <span class="wave">WAVE <b id="waveNum">1</b></span>
      <span class="lives">‚ô• <b id="livesNum">3</b></span>
    </div>
    <div id="startOverlay" class="overlay">
      <div class="kicker">NEON ARCADE</div>
      <h1>NEOX</h1>
      <p>‚Üê ‚Üí Ïù¥Îèô ¬∑ SPACE Î∞úÏÇ¨<br />Ïõ®Ïù¥Î∏å ÌÅ¥Î¶¨Ïñ¥ Ïãú Í≥®Îìú ¬∑ 5ÎùºÏö¥ÎìúÎßàÎã§ ÏÉÅÏ†ê</p>
      <button class="btn" id="startBtn">START</button>
    </div>
    <div id="gameOverOverlay" class="overlay game-over hidden">
      <div class="kicker">GAME OVER</div>
      <div class="final-score">SCORE <b id="finalScore">0</b></div>
      <button class="btn" id="restartBtn">RETRY</button>
    </div>
    <div id="shopOverlay" class="overlay hidden">
      <div class="shop">
        <h2 id="shopTitle">ÏÉÅÏ†ê ¬∑ WAVE 5 ÌÅ¥Î¶¨Ïñ¥!</h2>
        <div class="gold-display">ü™ô <b id="shopGold">0</b> GOLD</div>
        <div id="shopList"></div>
        <button class="btn btn-next" id="shopNextBtn">Îã§Ïùå Ïõ®Ïù¥Î∏å</button>
      </div>
    </div>
  </div>

  <script>
(function () {
  'use strict';

  const C = document.getElementById('c');
  const ctx = C.getContext('2d');
  const scoreEl = document.getElementById('scoreNum');
  const goldEl = document.getElementById('goldNum');
  const waveEl = document.getElementById('waveNum');
  const livesEl = document.getElementById('livesNum');
  const startOverlay = document.getElementById('startOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const shopOverlay = document.getElementById('shopOverlay');
  const shopTitle = document.getElementById('shopTitle');
  const shopGold = document.getElementById('shopGold');
  const shopList = document.getElementById('shopList');
  const shopNextBtn = document.getElementById('shopNextBtn');
  const finalScoreEl = document.getElementById('finalScore');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');

  let W, H, scale;
  function resize() {
    const wrap = C.parentElement;
    const r = wrap.getBoundingClientRect();
    W = r.width;
    H = r.height;
    C.width = W;
    C.height = H;
    scale = Math.min(W / 360, H / 480);
  }
  window.addEventListener('resize', resize);
  resize();

  const CS = {
    PLAYER_W: 24,
    PLAYER_H: 20,
    PLAYER_SPEED: 5.5,
    BULLET_SPEED: -10,
    BULLET_R: 3,
    ENEMY_W: 22,
    ENEMY_H: 18,
    ENEMY_COLS: 8,
    ENEMY_ROWS: 3,
    ENEMY_GAP: 8,
    ENEMY_DX: 1.8,
    ENEMY_DY: 14,
    PARTICLE_COUNT: 8,
    MISSILE_SPEED: 2.2,
    MISSILE_R: 4,
    MISSILE_HOMING: 0.06,
    MISSILE_TRACKING_MS: 300,
    DIVE_SPEED: 3,
    DIVE_HOMING: 0.038,
    ENEMY_SHOOT_INTERVAL: 2400,
    ENEMY_DIVE_INTERVAL: 4800,
    INVINCIBLE_MS: 1800,
    GOLD_PER_WAVE: 28,
    GOLD_WAVE_BONUS: 10,
  };

  let state = 'idle';
  let player = { x: 0, y: 0 };
  let bullets = [];
  let enemies = [];
  let enemyMissiles = [];
  let particles = [];
  let score = 0;
  let gold = 0;
  let wave = 1;
  let lives = 3;
  let maxLives = 5;
  let upgrades = { fireRate: 0, bulletSpeed: 0, moveSpeed: 0 };
  let enemyDir = 1;
  let enemyTick = 0;
  let lastFrame = 0;
  let lastShot = 0;
  let lastEnemyShoot = 0;
  let lastDiveSpawn = 0;
  let invincibleUntil = 0;
  let raf = 0;
  const stars = [];
  for (let i = 0; i < 80; i++) {
    stars.push({
      x: Math.random() * 360,
      y: Math.random() * 480,
      r: 0.5 + Math.random() * 1,
      br: 0.2 + Math.random() * 0.5,
    });
  }

  function spawnWave() {
    enemies = [];
    enemyMissiles = [];
    const baseX = (W - (CS.ENEMY_COLS * (CS.ENEMY_W + CS.ENEMY_GAP) - CS.ENEMY_GAP)) / 2 + (CS.ENEMY_W + CS.ENEMY_GAP) / 2;
    const baseY = 60;
    for (let row = 0; row < CS.ENEMY_ROWS + Math.min(wave - 1, 2); row++) {
      for (let col = 0; col < CS.ENEMY_COLS; col++) {
        enemies.push({
          x: baseX + col * (CS.ENEMY_W + CS.ENEMY_GAP),
          y: baseY + row * (CS.ENEMY_H + CS.ENEMY_GAP),
          type: row % 3,
          hit: false,
          diving: false,
          vx: 0,
          vy: 0,
        });
      }
    }
    enemyDir = 1;
    enemyTick = 0;
  }

  function addParticles(x, y, color) {
    for (let i = 0; i < CS.PARTICLE_COUNT; i++) {
      const a = (Math.PI * 2 * i) / CS.PARTICLE_COUNT + Math.random() * 0.5;
      const s = 2 + Math.random() * 4;
      particles.push({
        x, y,
        vx: Math.cos(a) * s,
        vy: Math.sin(a) * s,
        life: 1,
        color,
      });
    }
  }

  function hitTest(a, b, aw, ah, bw, bh) {
    return a.x < b.x + bw && a.x + aw > b.x && a.y < b.y + bh && a.y + ah > b.y;
  }

  function drawPlayer(t) {
    const x = player.x - CS.PLAYER_W / 2;
    const y = player.y - CS.PLAYER_H / 2;
    const w = CS.PLAYER_W;
    const h = CS.PLAYER_H;
    const inv = t < invincibleUntil;
    if (inv && Math.floor(t / 80) % 2 === 0) return;
    ctx.save();
    ctx.shadowColor = inv ? '#f472b6' : '#06b6d4';
    ctx.shadowBlur = inv ? 20 : 14;
    ctx.fillStyle = '#06b6d4';
    ctx.beginPath();
    ctx.moveTo(x, y + h);
    ctx.lineTo(x + w * 0.5, y);
    ctx.lineTo(x + w, y + h);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = '#22d3ee';
    ctx.beginPath();
    ctx.moveTo(x + w * 0.35, y + h * 0.6);
    ctx.lineTo(x + w * 0.5, y + h * 0.2);
    ctx.lineTo(x + w * 0.65, y + h * 0.6);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawBullet(b) {
    ctx.save();
    ctx.shadowColor = '#22d3ee';
    ctx.shadowBlur = 10;
    ctx.fillStyle = '#22d3ee';
    ctx.beginPath();
    ctx.arc(b.x, b.y, CS.BULLET_R, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function drawEnemy(e) {
    if (e.hit) return;
    const colors = ['#a78bfa', '#c084fc', '#f472b6'];
    const c = colors[e.type % colors.length];
    ctx.save();
    if (e.diving) {
      ctx.shadowColor = '#f472b6';
      ctx.shadowBlur = 16;
      ctx.globalAlpha = 0.9 + Math.sin(performance.now() * 0.01) * 0.1;
    } else {
      ctx.shadowColor = c;
      ctx.shadowBlur = 10;
    }
    ctx.fillStyle = e.diving ? '#f472b6' : c;
    ctx.fillRect(e.x - CS.ENEMY_W / 2, e.y - CS.ENEMY_H / 2, CS.ENEMY_W, CS.ENEMY_H);
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 1;
    ctx.strokeRect(e.x - CS.ENEMY_W / 2, e.y - CS.ENEMY_H / 2, CS.ENEMY_W, CS.ENEMY_H);
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawEnemyMissile(m) {
    ctx.save();
    ctx.shadowColor = '#f472b6';
    ctx.shadowBlur = 12;
    ctx.fillStyle = '#f472b6';
    ctx.beginPath();
    ctx.ellipse(m.x, m.y, CS.MISSILE_R * 0.6, CS.MISSILE_R, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();
  }

  function drawParticles() {
    particles.forEach(p => {
      ctx.save();
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 6;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });
  }

  function updateHud() {
    scoreEl.textContent = score;
    goldEl.textContent = gold;
    waveEl.textContent = wave;
    livesEl.textContent = lives;
  }

  function effectiveFireRate() {
    return 4 + upgrades.fireRate;
  }
  function effectiveBulletSpeed() {
    return CS.BULLET_SPEED * (1 + 0.22 * upgrades.bulletSpeed);
  }
  function effectiveMoveSpeed() {
    return CS.PLAYER_SPEED * (1 + 0.15 * upgrades.moveSpeed);
  }

  const SHOP_ITEMS = [
    { id: 'fireRate', name: 'Ïó∞ÏÇ¨ ÏÜçÎèÑ', desc: 'Ï¥àÎãπ Î∞úÏÇ¨ Ïàò +1', max: 3, prices: [55, 85, 115] },
    { id: 'bulletSpeed', name: 'ÎØ∏ÏÇ¨Ïùº ÏóÖÍ∑∏Î†àÏù¥Îìú', desc: 'ÌÉÑÏÜç +22%', max: 2, prices: [70, 95] },
    { id: 'moveSpeed', name: 'Ïù¥Îèô ÏÜçÎèÑ', desc: 'Ïù¥Îèô +15%', max: 2, prices: [60, 85] },
    { id: 'heal', name: 'Ï≤¥Î†• ÌöåÎ≥µ', desc: 'Ï≤¥Î†• +1 (ÏµúÎåÄ 5)', max: 99, prices: [90] },
  ];

  function renderShop() {
    shopTitle.textContent = 'ÏÉÅÏ†ê ¬∑ WAVE ' + (wave - 1) + ' ÌÅ¥Î¶¨Ïñ¥!';
    shopGold.textContent = gold;
    shopList.innerHTML = '';
    SHOP_ITEMS.forEach(item => {
      const div = document.createElement('div');
      div.className = 'shop-item';
      const lvl = item.id === 'heal' ? 0 : upgrades[item.id];
      const max = item.id === 'heal' ? '' : ' / ' + item.max;
      const price = item.id === 'heal' ? item.prices[0] : (item.prices[lvl] ?? 999);
      const canBuy = gold >= price && (item.id === 'heal' ? lives < maxLives : lvl < item.max);
      const name = item.id === 'heal' ? item.name : item.name + ' Lv.' + (lvl + 1);
      div.innerHTML =
        '<div class="info">' +
          '<div class="name">' + name + '</div>' +
          '<div class="lvl">' + item.desc + (item.id !== 'heal' && lvl > 0 ? ' ¬∑ Lv.' + lvl + max : '') + '</div>' +
        '</div>' +
        '<button class="btn-buy" data-id="' + item.id + '" ' + (canBuy ? '' : 'disabled') + '>' +
          (item.id === 'heal' && lives >= maxLives ? 'MAX' : (canBuy ? price + ' G' : '‚Äî')) +
        '</button>';
      shopList.appendChild(div);
    });
    shopList.querySelectorAll('.btn-buy').forEach(btn => {
      if (btn.disabled) return;
      btn.addEventListener('click', () => buyUpgrade(btn.dataset.id));
    });
  }

  function buyUpgrade(id) {
    const item = SHOP_ITEMS.find(i => i.id === id);
    if (!item) return;
    if (id === 'heal') {
      if (lives >= maxLives || gold < item.prices[0]) return;
      gold -= item.prices[0];
      lives = Math.min(maxLives, lives + 1);
    } else {
      const lvl = upgrades[id];
      if (lvl >= item.max || gold < (item.prices[lvl] ?? 999)) return;
      gold -= item.prices[lvl];
      upgrades[id]++;
    }
    renderShop();
    updateHud();
  }

  function openShop() {
    state = 'shop';
    updateHud();
    renderShop();
    shopOverlay.classList.remove('hidden');
  }

  function closeShopAndNextWave() {
    shopOverlay.classList.add('hidden');
    state = 'play';
    spawnWave();
    lastEnemyShoot = lastDiveSpawn = performance.now();
    raf = requestAnimationFrame(loop);
  }

  function gameOver() {
    state = 'over';
    cancelAnimationFrame(raf);
    finalScoreEl.textContent = score;
    gameOverOverlay.classList.remove('hidden');
  }

  function loop() {
    if (state !== 'play') return;
    const now = performance.now();
    const dt = Math.min((now - lastFrame) / 1000, 0.05);
    lastFrame = now;

    ctx.clearRect(0, 0, W, H);
    ctx.save();
    ctx.scale(W / 360, H / 480);
    ctx.fillStyle = 'rgba(6, 182, 212, 0.15)';
    stars.forEach(s => {
      ctx.globalAlpha = 0.3 + Math.sin(now * 0.002 + s.x) * s.br;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    ctx.strokeStyle = 'rgba(6, 182, 212, 0.06)';
    ctx.lineWidth = 1;
    for (let x = 0; x < 360; x += 24) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, 480);
      ctx.stroke();
    }
    for (let y = 0; y < 480; y += 24) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(360, y);
      ctx.stroke();
    }
    ctx.restore();

    const spd = effectiveMoveSpeed() * 60 * dt;
    if (keys['ArrowLeft'] || touchBtns.left) player.x -= spd;
    if (keys['ArrowRight'] || touchBtns.right) player.x += spd;
    if (keys['Space'] || touchBtns.fire) tryShoot();
    player.x = Math.max(CS.PLAYER_W / 2, Math.min(W - CS.PLAYER_W / 2, player.x));

    const bSpeed = effectiveBulletSpeed();
    bullets.forEach(b => { b.y += bSpeed * 60 * dt; });
    bullets = bullets.filter(b => b.y > -10);

    const alive = enemies.filter(e => !e.hit);
    const formation = alive.filter(e => !e.diving);

    if (alive.length === 0) {
      const cleared = wave;
      gold += CS.GOLD_PER_WAVE + cleared * CS.GOLD_WAVE_BONUS;
      score += 400 + cleared * 50;
      wave++;
      if (wave % 5 === 1) {
        drawPlayer(now);
        bullets.forEach(drawBullet);
        enemyMissiles.forEach(drawEnemyMissile);
        enemies.forEach(drawEnemy);
        drawParticles();
        openShop();
        return;
      }
      spawnWave();
    }

    const shootInterval = Math.max(1200, CS.ENEMY_SHOOT_INTERVAL - (wave - 1) * 50);
    if (formation.length > 0 && now - lastEnemyShoot >= shootInterval) {
      lastEnemyShoot = now;
      const shooter = formation[Math.floor(Math.random() * formation.length)];
      const dx = (player.x - shooter.x) * 0.002;
      enemyMissiles.push({
        x: shooter.x,
        y: shooter.y + CS.ENEMY_H / 2,
        vx: Math.max(-1.2, Math.min(1.2, dx)),
        vy: CS.MISSILE_SPEED,
        spawnedAt: now,
      });
    }

    const diveInterval = Math.max(2800, CS.ENEMY_DIVE_INTERVAL - (wave - 1) * 120);
    const diveCands = formation.filter(e => !e.diving);
    if (diveCands.length > 0 && now - lastDiveSpawn >= diveInterval) {
      lastDiveSpawn = now;
      const d = diveCands[Math.floor(Math.random() * diveCands.length)];
      d.diving = true;
      const dx = player.x - d.x;
      const dy = player.y - d.y;
      const len = Math.hypot(dx, dy) || 1;
      d.vx = (dx / len) * CS.DIVE_SPEED;
      d.vy = (dy / len) * CS.DIVE_SPEED;
    }

    enemyMissiles.forEach(m => {
      const age = now - (m.spawnedAt || 0);
      const tracking = age < CS.MISSILE_TRACKING_MS;
      if (tracking) {
        const dx = player.x - m.x;
        const dy = player.y - m.y;
        const len = Math.hypot(dx, dy) || 1;
        m.vx += (dx / len) * CS.MISSILE_HOMING * 60 * dt;
        m.vy += (dy / len) * CS.MISSILE_HOMING * 60 * dt;
        const ml = Math.hypot(m.vx, m.vy) || 1;
        m.vx = (m.vx / ml) * CS.MISSILE_SPEED;
        m.vy = (m.vy / ml) * CS.MISSILE_SPEED;
      }
      m.x += m.vx * 60 * dt;
      m.y += m.vy * 60 * dt;
    });
    enemyMissiles = enemyMissiles.filter(m => m.y < H + 20);

    alive.filter(e => e.diving).forEach(e => {
      const dx = player.x - e.x;
      const dy = player.y - e.y;
      const len = Math.hypot(dx, dy) || 1;
      e.vx += (dx / len) * CS.DIVE_HOMING * 60 * dt;
      e.vy += (dy / len) * CS.DIVE_HOMING * 60 * dt;
      const vl = Math.hypot(e.vx, e.vy) || 1;
      e.vx = (e.vx / vl) * CS.DIVE_SPEED;
      e.vy = (e.vy / vl) * CS.DIVE_SPEED;
      e.x += e.vx * 60 * dt;
      e.y += e.vy * 60 * dt;
      if (e.y > H + 40 || e.x < -40 || e.x > W + 40) e.hit = true;
    });

    enemyTick += 60 * dt;
    if (enemyTick >= 45) {
      enemyTick = 0;
      let edge = false;
      formation.forEach(e => {
        e.x += CS.ENEMY_DX * enemyDir;
        if (e.x <= CS.ENEMY_W / 2 + 4 || e.x >= W - CS.ENEMY_W / 2 - 4) edge = true;
      });
      if (edge) {
        enemyDir *= -1;
        formation.forEach(e => { e.y += CS.ENEMY_DY; });
      }
    }

    bullets.forEach(b => {
      alive.forEach(e => {
        if (hitTest(
          { x: b.x - CS.BULLET_R, y: b.y - CS.BULLET_R },
          { x: e.x - CS.ENEMY_W / 2, y: e.y - CS.ENEMY_H / 2 },
          CS.BULLET_R * 2, CS.BULLET_R * 2,
          CS.ENEMY_W, CS.ENEMY_H
        )) {
          e.hit = true;
          b.dead = true;
          const colors = ['#a78bfa', '#c084fc', '#f472b6'];
          addParticles(e.x, e.y, colors[e.type % 3]);
          score += (e.type + 1) * 50;
          if (e.diving) score += 80;
        }
      });
    });
    bullets = bullets.filter(b => !b.dead);

    const inv = now < invincibleUntil;
    if (!inv) {
      enemyMissiles.forEach(m => {
        if (hitTest(
          { x: player.x - CS.PLAYER_W / 2, y: player.y - CS.PLAYER_H / 2 },
          { x: m.x - CS.MISSILE_R, y: m.y - CS.MISSILE_R },
          CS.PLAYER_W, CS.PLAYER_H,
          CS.MISSILE_R * 2, CS.MISSILE_R * 2
        )) {
          m.dead = true;
          addParticles(m.x, m.y, '#f472b6');
          lives--;
          invincibleUntil = now + CS.INVINCIBLE_MS;
          if (lives <= 0) { gameOver(); return; }
        }
      });
      enemyMissiles = enemyMissiles.filter(m => !m.dead);
      alive.filter(e => e.diving).forEach(e => {
        if (hitTest(
          { x: player.x - CS.PLAYER_W / 2, y: player.y - CS.PLAYER_H / 2 },
          { x: e.x - CS.ENEMY_W / 2, y: e.y - CS.ENEMY_H / 2 },
          CS.PLAYER_W, CS.PLAYER_H,
          CS.ENEMY_W, CS.ENEMY_H
        )) {
          e.hit = true;
          addParticles(e.x, e.y, '#f472b6');
          lives--;
          invincibleUntil = now + CS.INVINCIBLE_MS;
          if (lives <= 0) { gameOver(); return; }
        }
      });
      formation.forEach(e => {
        if (e.y + CS.ENEMY_H / 2 >= player.y - CS.PLAYER_H / 2 - 5) {
          e.hit = true;
          addParticles(e.x, e.y, '#f472b6');
          lives--;
          invincibleUntil = now + CS.INVINCIBLE_MS;
          if (lives <= 0) gameOver();
        }
      });
    }

    particles.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.life -= 0.03;
    });
    particles = particles.filter(p => p.life > 0);

    drawPlayer(now);
    bullets.forEach(drawBullet);
    enemyMissiles.forEach(drawEnemyMissile);
    enemies.forEach(drawEnemy);
    drawParticles();
    updateHud();

    raf = requestAnimationFrame(loop);
  }

  const keys = {};

  function tryShoot() {
    if (state !== 'play') return;
    const now = performance.now();
    if (now - lastShot < 1000 / effectiveFireRate()) return;
    lastShot = now;
    bullets.push({
      x: player.x,
      y: player.y - CS.PLAYER_H / 2 - 4,
      dead: false,
    });
  }

  document.addEventListener('keydown', e => {
    if (['Space', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
    keys[e.code] = true;
    if (e.code === 'Space') tryShoot();
  });
  document.addEventListener('keyup', e => { keys[e.code] = false; });

  const touchBtns = { left: false, right: false, fire: false };
  function setupTouch() {
    const wrap = C.parentElement;
    const left = document.createElement('button');
    const right = document.createElement('button');
    const fire = document.createElement('button');
    left.className = right.className = fire.className = 'touch-btn';
    left.textContent = '‚óÄ';
    right.textContent = '‚ñ∂';
    fire.textContent = 'FIRE';
    left.style.cssText = 'position:absolute;left:12px;bottom:24px;width:56px;height:56px;border-radius:50%;border:2px solid rgba(6,182,212,0.5);background:rgba(6,182,212,0.15);color:#22d3ee;font-size:18px;cursor:pointer;z-index:15;touch-action:manipulation;';
    right.style.cssText = 'position:absolute;left:80px;bottom:24px;width:56px;height:56px;border-radius:50%;border:2px solid rgba(6,182,212,0.5);background:rgba(6,182,212,0.15);color:#22d3ee;font-size:18px;cursor:pointer;z-index:15;touch-action:manipulation;';
    fire.style.cssText = 'position:absolute;right:12px;bottom:24px;width:72px;height:56px;border-radius:12px;border:2px solid rgba(167,139,250,0.5);background:rgba(167,139,250,0.15);color:#a78bfa;font-size:11px;font-weight:700;cursor:pointer;z-index:15;touch-action:manipulation;';
    [left, right, fire].forEach(el => {
      el.addEventListener('mousedown', (e) => { e.preventDefault(); });
      el.addEventListener('touchstart', (e) => { e.preventDefault(); });
    });
    left.addEventListener('mousedown', () => { touchBtns.left = true; });
    left.addEventListener('mouseup', () => { touchBtns.left = false; });
    left.addEventListener('mouseleave', () => { touchBtns.left = false; });
    left.addEventListener('touchstart', () => { touchBtns.left = true; });
    left.addEventListener('touchend', () => { touchBtns.left = false; });
    right.addEventListener('mousedown', () => { touchBtns.right = true; });
    right.addEventListener('mouseup', () => { touchBtns.right = false; });
    right.addEventListener('mouseleave', () => { touchBtns.right = false; });
    right.addEventListener('touchstart', () => { touchBtns.right = true; });
    right.addEventListener('touchend', () => { touchBtns.right = false; });
    fire.addEventListener('mousedown', () => { touchBtns.fire = true; tryShoot(); });
    fire.addEventListener('touchstart', () => { touchBtns.fire = true; tryShoot(); });
    fire.addEventListener('mouseup', () => { touchBtns.fire = false; });
    fire.addEventListener('mouseleave', () => { touchBtns.fire = false; });
    fire.addEventListener('touchend', () => { touchBtns.fire = false; });
    wrap.appendChild(left);
    wrap.appendChild(right);
    wrap.appendChild(fire);
  }
  setupTouch();

  function start() {
    resize();
    state = 'play';
    score = 0;
    gold = 0;
    wave = 1;
    lives = 3;
    maxLives = 5;
    upgrades = { fireRate: 0, bulletSpeed: 0, moveSpeed: 0 };
    player.x = W / 2;
    player.y = H - 56;
    bullets = [];
    particles = [];
    invincibleUntil = 0;
    const t = performance.now();
    lastEnemyShoot = lastDiveSpawn = t;
    spawnWave();
    startOverlay.classList.add('hidden');
    gameOverOverlay.classList.add('hidden');
    shopOverlay.classList.add('hidden');
    lastFrame = lastShot = t;
    updateHud();
    raf = requestAnimationFrame(loop);
  }

  startBtn.addEventListener('click', start);
  restartBtn.addEventListener('click', start);
  shopNextBtn.addEventListener('click', closeShopAndNextWave);
})();
  </script>
</body>
</html>
